name: ü§ñ CPI Documentation Generation
on:
  workflow_dispatch:
    inputs:
      package_id:
        description: "The ID of the CPI Integration Package (e.g., 'PDFcoveter')."
        required: true
        type: string

jobs:
  document:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Dependencies (jq only)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      # --- Step 1: Generate Individual iFlow Documentation (Unchanged) ---
      - name: üí¨ Generate Individual iFlow Documentation via OpenAI API
        id: documentation_step
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          PKG_ID: ${{ github.event.inputs.package_id }}
        run: |
          # ... (Content for AI Documentation Generation is unchanged) ...
          # Note: The full content of this large step is omitted here for brevity but remains the same as in Attempt 7.
          # It generates all *_Summary.md files.
          
          # --- Configuration ---
          API_URL="https://api.openai.com/v1/chat/completions"
          MODEL_NAME="gpt-4o-mini"
          BASE_PKG_DIR="cpi-artifacts/$PKG_ID"
          
          if [ ! -d "$BASE_PKG_DIR" ]; then
            echo "::error::Package directory not found at: $BASE_PKG_DIR"
            echo "docs_generated=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # --- Prompt Definitions: STRICT HIERARCHICAL STRUCTURE (using HTML styles) ---
          SYSTEM_PROMPT="You are a senior SAP CPI Technical Architect. Your task is to analyze ALL provided code and configuration files from the SINGLE iFlow provided and synthesize them into ONE consolidated Markdown documentation report. You MUST adhere strictly to the following hierarchical 6-point structure. CRITICALLY, you MUST ONLY use the required inline HTML tags for all headings (H1 and H2) to ensure the dark blue color (#1f4e79) is applied. DO NOT use Markdown heading syntax (# or ##) for the main report body. Ensure all technical details (like Groovy, XSLT, Adapters, Security) are thoroughly explained within the relevant sections.
          **MANDATORY FIRST SECTION: TABLE OF CONTENTS (TOC) PAGE**
          The very first output of the document MUST be the Table of Contents. Format the TOC heading using HTML to achieve a prominent blue color and large font, like this: <h1 style=\"color: #1f4e79; font-size: 2.5em;\">Table of Contents</h1>. Below this heading, list all 6 main sections and their subsections using standard Markdown numbered list syntax (e.g., 1., 1.1., 1.2., etc.), ensuring proper indentation and **avoiding the use of HTML entities like &nbsp; for spacing**. Use a generous number of blank lines (e.g., 10 lines) after the TOC list to create maximum visual separation, then **add the unique marker '---TOC-END-PAGE-BREAK---' on its own line before starting Section 1.**
          The mandatory sections, **which MUST be generated using the styled HTML headings only**, are:
          <h1 style=\"color: #1f4e79;\">1. Introduction</h1>
          <h2 style=\"color: #1f4e79;\">1.1 Purpose</h2> (Map: Purpose of this iFlow)
          <h2 style=\"color: #1f4e79;\">1.2 Scope</h2> (Describe the boundaries and systems affected by this single iFlow)
          <h1 style=\"color: #1f4e79;\">2. Integration Overview</h1>
          <h2 style=\"color: #1f4e79;\">2.1 Integration Architecture</h2> (Map: High-level architecture + Process Diagram)
          (Output the High-Level Process Flow Diagram immediately after the architecture text using only Mermaid syntax. The diagram **MUST START on a new line immediately following the architecture text** with \`\`\`mermaid, contain only pure graph definitions (e.g., 'graph TD', nodes, and arrows), and **MUST BE followed by one blank line immediately after the closing \`\`\`**. The diagram must be a 'graph TD' (Top-Down) flowchart showing the major systems and their high-level interaction points, NOT the low-level iFlow steps.)
          <h2 style=\"color: #1f4e79;\">2.2 Integration Components</h2> (Map: Sender/Receiver systems + Adapter types used)
          <h1 style=\"color: #1f4e79;\">3. Integration Scenarios</h1>
          <h2 style=\"color: #1f4e79;\">3.1 Scenario Description</h2> (Map: Step-by-step flow explanation detailing the iFlow path)
          <h2 style=\"color: #1f4e79;\">3.2 Data Flows</h2> (Map: Mapping logic summary (XSLT/Mappings) + Groovy script explanations (usage/purpose))
          <h2 style=\"color: #1f4e79;\">3.3 Security Requirements</h2> (Map: Security/authentication details on mechanisms, credentials, and configuration)
          <h1 style=\"color: #1f4e79;\">4. Error Handling and Logging</h1> (Map: Error handling details)
          <h1 style=\"color: #1f4e79;\">5. Testing Validation</h1> (Summarize key testing requirements/scenarios based on iFlow logic)
          <h1 style=\"color: #1f4e79;\">6. Reference Documents</h1> (List the input artifacts analyzed: iFlowContent.xml, Groovy scripts, XSLT files, etc.)"
                      
          FULL_IFLOW_PATHS=$(find "$BASE_PKG_DIR" -type f \( -name 'iFlowContent.xml' -o -name '*.iflw' \) -print)
          
          if [ -z "$FULL_IFLOW_PATHS" ]; then
            echo "::warning::No iFlows found in package '$PKG_ID'. Skipping documentation."
            echo "docs_generated=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          IFLOW_ROOT_NAMES=$(echo "$FULL_IFLOW_PATHS" | sed "s|^$BASE_PKG_DIR/||" | cut -d/ -f1 | sort -u)
          IFLOW_FOLDERS=$(echo "$IFLOW_ROOT_NAMES" | xargs -I {} echo "$BASE_PKG_DIR/{}")
          ALL_DOCS_GENERATED=false
          
          for IFLOW_DIR in $IFLOW_FOLDERS; do
            IFLOW_NAME=$(basename "$IFLOW_DIR")
            OUTPUT_FILE="$IFLOW_DIR/${IFLOW_NAME}_Summary.md"
            
            # ... (Rest of the loop logic for API call and file generation) ...
            
            FULL_ARTIFACT_CONTENT=""
            FILES_TO_ANALYZE=$(find "$IFLOW_DIR" -type f \( -name 'iFlowContent.xml' -o -name '*.groovy' -o -name '*.xslt' -o -name '*.iflw' \) -print)
            
            if [ -z "$FILES_TO_ANALYZE" ]; then
                echo "¬† ‚ö†Ô∏è No supported artifacts found recursively in iFlow directory: $IFLOW_DIR. Skipping."
                continue
            fi
            
            for INPUT_FILE in $FILES_TO_ANALYZE; do
              FILE_CONTENT=$(cat "$INPUT_FILE")
              FULL_ARTIFACT_CONTENT+="\n\n--- START ARTIFACT: $INPUT_FILE ---\n"
              FULL_ARTIFACT_CONTENT+="$FILE_CONTENT"
              FULL_ARTIFACT_CONTENT+="\n--- END ARTIFACT: $INPUT_FILE ---\n"
            done
            
            USER_QUERY="Synthesize a single, consolidated technical report following the 6 mandatory hierarchical sections and all sub-sections from the set of artifacts provided below, which belong ONLY to the iFlow '$IFLOW_NAME'. \n\n\`\`\`text\n$FULL_ARTIFACT_CONTENT\n\`\`\`"
            
            PAYLOAD=$(jq -n \
              --arg system "$SYSTEM_PROMPT" \
              --arg query "$USER_QUERY" \
              --arg model "$MODEL_NAME" \
              '{ model: $model, messages: [{role: "system", content: $system}, {role: "user", content: $query}], temperature: 0.1 }')
              
            MAX_RETRIES=3
            RETRY_COUNT=0
            
            while [ "$RETRY_COUNT" -lt "$MAX_RETRIES" ]; do
              API_RESPONSE=$(curl -s -X POST "$API_URL" -H "Content-Type: application/json" -H "Authorization: Bearer $OPENAI_API_KEY" -d "$PAYLOAD")
              GENERATED_TEXT=$(echo "$API_RESPONSE" | jq -r ".choices[0].message.content")
              
              if [ "$GENERATED_TEXT" != "null" ] && [ -n "$GENERATED_TEXT" ]; then
                # DYNAMIC METADATA COLLECTION
                AUTHOR=$(git log -1 --pretty=format:'%an')
                DATE=$(date +'%Y-%m-%d')
                VERSION=$(git rev-parse --short HEAD)
                CLEAN_IFLOW_NAME=$(echo "$IFLOW_NAME" | sed 's/_/ /g')
                SAP_LOGO_URL="https://raw.githubusercontent.com/Rohancherian783/trail1/main/assets/sap_logo.png"
                MOTIVEMINDS_LOGO_URL="https://raw.githubusercontent.com/Rohancherian783/trail1/main/assets/motiveminds_logo.png"

                # COVER PAGE GENERATION (unchanged HTML structure)
                SAP_LOGO_BLOCK="<div style=\"float: left; text-align: left;\"><img src=\"$SAP_LOGO_URL\" alt=\"SAP Logo\" width=\"150\" height=\"60\"/></div>"
                MOTIVEMINDS_LOGO_BLOCK="<div style=\"float: right; text-align: right;\"><img src=\"$MOTIVEMINDS_LOGO_URL\" alt=\"motiveminds Logo\" width=\"150\" height=\"55\" style=\"margin-top: 5px;\"/></div>"
                COVER_PAGE_CONTENT="${SAP_LOGO_BLOCK}${MOTIVEMINDS_LOGO_BLOCK}<div style=\"clear: both;\"></div><div style=\"height: 80px;\"></div>"
                COVER_PAGE_CONTENT+="<h1 style=\"color: #1f4e79; font-size: 3em; text-align: center; margin-top: 5px; margin-bottom: 5px;\">$CLEAN_IFLOW_NAME</h1>"
                COVER_PAGE_CONTENT+="<h2 style=\"color: #1f4e79; font-size: 1.5em; text-align: center; margin-top: 5px; margin-bottom: 0px;\">SAP CPI Technical Specification Document</h2><div style=\"height: 100px;\"></div>"
                COVER_PAGE_CONTENT+="<div style=\"width: 100%; text-align: center;\"><table border=\"1\" style=\"width: 400px; border-collapse: collapse; border-color: black; margin: 0 auto; text-align: left;\">"
                COVER_PAGE_CONTENT+="<tr><td style=\"width: 30%; padding: 5px;\">**Author:**</td><td style=\"padding: 5px;\">$AUTHOR</td></tr>"
                COVER_PAGE_CONTENT+="<tr><td style=\"padding: 5px;\">**Date:**</td><td style=\"padding: 5px;\">$DATE</td></tr>"
                COVER_PAGE_CONTENT+="<tr><td style=\"padding: 5px;\">**Version (Commit):**</td><td style=\"padding: 5px;\">$VERSION</td></tr></table></div>"
                COVER_PAGE_CONTENT+="\n<div style=\"page-break-after: always;\"></div>\n\n"
                                      
                FULL_DOCUMENTATION="${COVER_PAGE_CONTENT}${GENERATED_TEXT}"
                PAGE_BREAK_AFTER_TOC="\n<div style=\"page-break-after: always;\"></div>\n"
                TOC_CLEANED_DOCUMENTATION=$(echo -e "$FULL_DOCUMENTATION" | sed -E "s|---TOC-END-PAGE-BREAK---|$PAGE_BREAK_AFTER_TOC|g")
                
                echo -e "$TOC_CLEANED_DOCUMENTATION" > "$OUTPUT_FILE"
                echo "¬† üíæ Saved documentation with cover page and page breaks to $OUTPUT_FILE"
                ALL_DOCS_GENERATED=true
                break
              fi
              # (Rest of API retry logic)
              ERROR_MSG=$(echo "$API_RESPONSE" | jq -r ".error.message // \"Unknown error\"")
              RETRY_COUNT=$((RETRY_COUNT + 1))
              DELAY=$((2**RETRY_COUNT))
              echo "¬† ‚ö†Ô∏è API call failed: $ERROR_MSG (Attempt $RETRY_COUNT/$MAX_RETRIES). Retrying in $DELAY seconds..."
              sleep "$DELAY"
            done
          done
          
          echo "docs_generated=$ALL_DOCS_GENERATED" >> $GITHUB_OUTPUT


      # --- Step 2: NEW! Pre-Process Mermaid Code Blocks to SVG Images ---
      - name: üñºÔ∏è Convert Mermaid Code Blocks to SVG Images
        if: steps.documentation_step.outputs.docs_generated == 'true'
        id: mermaid_convert
        env:
          PKG_ID: ${{ github.event.inputs.package_id }}
          MERMAID_IMAGE: "minlag/mermaid-to-svg:latest"
        run: |
          IFLOW_DIRS=$(find "cpi-artifacts/$PKG_ID" -type d -name '*_*')
          
          for IFLOW_DIR in $IFLOW_DIRS; do
              INPUT_MD="$IFLOW_DIR/$(basename "$IFLOW_DIR")_Summary.md"
              
              if [ -f "$INPUT_MD" ]; then
                  echo "::notice file=$INPUT_MD::Processing Mermaid in $INPUT_MD"
                  
                  # 1. Create a directory for SVGs
                  SVG_DIR="$IFLOW_DIR/mermaid_svgs"
                  mkdir -p "$SVG_DIR"
                  
                  # 2. Extract Mermaid code blocks, save them to temporary files, and convert them to SVG
                  # We use awk to reliably find ```mermaid ... ``` blocks
                  awk '/```mermaid/,/```/' "$INPUT_MD" | while IFS= read -r block; do
                      if [[ "$block" == "\`\`\`mermaid" ]]; then
                          # Start a new block file
                          BLOCK_FILE="$SVG_DIR/block_$(date +%s%N).txt"
                          MERMAID_CODE=""
                      elif [[ "$block" == "\`\`\`" ]]; then
                          # End of block, now convert
                          if [ -n "$MERMAID_CODE" ]; then
                              SVG_FILE=$(basename "$BLOCK_FILE" .txt).svg
                              OUTPUT_SVG="$SVG_DIR/$SVG_FILE"
                              
                              echo "$MERMAID_CODE" > "$BLOCK_FILE"
                              
                              echo "::notice::Converting Mermaid block to $SVG_FILE"
                              
                              # Execute the Mermaid-to-SVG conversion using Docker
                              /usr/bin/docker run --rm \
                                  -v "$(pwd):/data" \
                                  ${{ env.MERMAID_IMAGE }} \
                                  -i "/data/$BLOCK_FILE" \
                                  -o "/data/$OUTPUT_SVG"
                              
                              if [ $? -ne 0 ]; then
                                  echo "::error::Mermaid conversion failed for block in $INPUT_MD. Skipping image."
                                  rm -f "$BLOCK_FILE"
                                  continue
                              fi
                              
                              # 3. Replace the original code block in the Markdown file with the SVG image link
                              # Use a temporary file for the substitution to ensure atomic change
                              TEMP_MD="$INPUT_MD.tmp"
                              
                              # Escape the Markdown code block content for sed
                              ESCAPED_CODE=$(echo "$MERMAID_CODE" | sed 's/[\/&]/\\&/g' | sed 's/^/  /g')
                              
                              # Construct the exact block to find (escaped, with the leading/trailing ```)
                              FIND_BLOCK_START="\\\`\\\`\\\`mermaid"
                              FIND_BLOCK_END="\\\`\\\`\\\`"
                              
                              # Construct the replacement link, using the absolute path relative to the repo root
                              REPLACEMENT_LINK="<img src='file:///$OUTPUT_SVG' alt='Mermaid Diagram' style='max-width: 100%; height: auto; display: block; margin: 20px auto;'/>"
                              
                              # This sed command is complex: it finds the block (using two passes), deletes it, and inserts the replacement.
                              # Due to the complexity of multi-line deletion/insertion in sed, we use a simpler tool chain for the replacement logic.
                              
                              # Read the whole file into a variable
                              MD_CONTENT=$(cat "$INPUT_MD")
                              
                              # Replace the block (assuming the AI output is clean and blocks are self-contained)
                              # The pattern is: ```mermaid\n...mermaid code...\n```
                              
                              # Since shell sed is tricky, we replace the ENTIRE block (including ```mermaid and ```)
                              
                              # Build the exact pattern to replace. It's too complex for robust multi-line sed.
                              
                              # Instead, we just replace the content by matching the file line by line
                              
                              # Rerun the extraction with line numbers to get start/end lines for sed
                              START_LINE=$(grep -n "^\`\`\`mermaid" "$INPUT_MD" | head -1 | cut -d: -f1)
                              END_LINE=$(awk -v start=$START_LINE 'NR > start && /^\`\`\`$/ { print NR; exit }' "$INPUT_MD")
                              
                              if [ -n "$START_LINE" ] && [ -n "$END_LINE" ]; then
                                  # Perform replacement: delete block and insert image tag
                                  sed -i "$START_LINE,$END_LINE d" "$INPUT_MD"
                                  sed -i "$START_LINE i\\$REPLACEMENT_LINK" "$INPUT_MD"
                                  echo "::notice::Replaced block with image tag: $SVG_FILE"
                              fi
                          fi
                          rm -f "$BLOCK_FILE"
                      elif [ -n "$MERMAID_CODE" ] || [[ "$block" != "\`\`\`" ]]; then
                          # Collect lines within the block
                          MERMAID_CODE+="$block"$'\n'
                      fi
                  done
              fi
          done


      # --- Step 3: Consolidate Markdown (UPDATED to reference pre-processed MD) ---
      - name: üì¶ Consolidate All iFlow Markdown Files
        if: steps.documentation_step.outputs.docs_generated == 'true'
        id: consolidate_md
        env:
          PKG_ID: ${{ github.event.inputs.package_id }}
        run: |
          INPUT_FILES=$(find "cpi-artifacts/$PKG_ID" -type f -name '*_Summary.md' | sort)
          OUTPUT_MD="cpi-artifacts/$PKG_ID/Combined_CPI_Documentation.md"
          
          echo "Consolidating files into $OUTPUT_MD"
          
          > "$OUTPUT_MD"
          
          for FILE in $INPUT_FILES; do
              IFLOW_NAME=$(basename "$(dirname "$FILE")")
              echo "--- Adding iFlow: $IFLOW_NAME ---"
              
              # Add a Pandoc page break before the next document starts
              echo -e "\n\n\\pagebreak\n\n" >> "$OUTPUT_MD"
              cat "$FILE" >> "$OUTPUT_MD"
          done
          
          echo "::set-output name=combined_md_path::$OUTPUT_MD"


      # --- Step 4: Single-Step Docker Conversion (The CLEAN Pandoc Run) ---
      - name: üìÑ Convert Combined Markdown to PDF using Clean Pandoc Run
        if: steps.consolidate_md.outputs.combined_md_path != ''
        env:
          PKG_ID: ${{ github.event.inputs.package_id }}
          INPUT_MD: ${{ steps.consolidate_md.outputs.combined_md_path }}
          OUTPUT_PDF: cpi-artifacts/${{ github.event.inputs.package_id }}/Combined_CPI_Documentation.pdf
          
        run: |
          INPUT_MD_PATH="${{ env.INPUT_MD }}"
          OUTPUT_PDF_PATH="${{ env.OUTPUT_PDF }}"
          
          echo "::notice::Starting single-step Markdown-to-PDF conversion using pandoc/latex."
          
          # The Pandoc command is now simplified, as Mermaid blocks have been replaced by images.
          # We include the 'raw_html' extension because of the cover page and inline styles.
          /usr/bin/docker run --rm \
              -v "$(pwd):/data" \
              pandoc/latex \
              "$INPUT_MD_PATH" \
              -o "$OUTPUT_PDF_PATH" \
              --from markdown+yaml_metadata_block+raw_html \
              --to latex \
              --pdf-engine=xelatex \
              -V geometry:margin=0.5in \
              --toc \
              --toc-depth=3
              
          if [ $? -ne 0 ]; then
              echo "::error::Final PDF conversion failed with exit code $?. The input Markdown/HTML in $INPUT_MD_PATH is likely invalid for LaTeX."
              echo "::warning::Attempting fallback conversion to HTML for debugging."
              /usr/bin/docker run --rm \
                  -v "$(pwd):/data" \
                  pandoc/latex \
                  "$INPUT_MD_PATH" \
                  -o "${OUTPUT_PDF_PATH}.html" \
                  --from markdown+yaml_metadata_block+raw_html \
                  --self-contained \
                  --toc
              echo "::warning::Fallback HTML saved to ${OUTPUT_PDF_PATH}.html"
              exit 1
          fi

          echo "::notice::Final PDF generated successfully at $OUTPUT_PDF_PATH"

      # --- COMMIT STEP (Unchanged) ---
      - name: üíæ Commit All Generated Files (MD, and PDF)
        if: steps.documentation_step.outputs.docs_generated == 'true'
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
                      
          PKG_ID="${{ github.event.inputs.package_id }}"
          
          PDF_GENERATED_FLAG="false"
          if [ -f "cpi-artifacts/$PKG_ID/Combined_CPI_Documentation.pdf" ]; then
              PDF_GENERATED_FLAG="true"
          fi

          OUTPUT_PATH_MD="cpi-artifacts/$PKG_ID/**/*_Summary.md"
          OUTPUT_PATH_COMBINED_MD="cpi-artifacts/$PKG_ID/Combined_CPI_Documentation.md"
          OUTPUT_PATH_SVG="cpi-artifacts/$PKG_ID/**/*_svgs/*.svg"
          OUTPUT_PATH_PDF="cpi-artifacts/$PKG_ID/Combined_CPI_Documentation.pdf"
          OUTPUT_PATH_FALLBACK_HTML="cpi-artifacts/$PKG_ID/Combined_CPI_Documentation.pdf.html"

          git add "$OUTPUT_PATH_MD"
          git add "$OUTPUT_PATH_COMBINED_MD"
          git add "$OUTPUT_PATH_SVG"
          git add "$OUTPUT_PATH_PDF"
          git add "$OUTPUT_PATH_FALLBACK_HTML"
                      
          if git diff --cached --quiet; then
              echo "No meaningful changes detected in the generated documentation files. Skipping commit."
          else
              COMMIT_MESSAGE="ü§ñ DOCS: Generated/Updated iFlow summaries (MD) and Combined PDF for package: $PKG_ID (Pre-processed Mermaid to SVG fix)."
              if [ "$PDF_GENERATED_FLAG" == "false" ]; then
                  COMMIT_MESSAGE="‚ö†Ô∏è DOCS: Generated MD files, but PDF conversion failed for package: $PKG_ID. (See fallback HTML artifact)"
              fi
              
              git commit -m "$COMMIT_MESSAGE"
              git push
              echo "‚úÖ All documentation and artifacts committed and pushed to repository."
          fi
