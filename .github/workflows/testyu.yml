name: ðŸ¤– test Documentation
on:
  workflow_dispatch:
    inputs:
      package_id:
        description: "The ID of the CPI Integration Package (e.g., 'PDFcoveter')."
        required: true
        type: string
jobs:
  document:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed to commit the generated documentation
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Install Dependencies (jq only)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
      - name: Generate Individual iFlow Documentation via OpenAI API
        id: documentation_step
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          PKG_ID: ${{ github.event.inputs.package_id }}
        run: |
          # --- Configuration ---
          API_URL="https://api.openai.com/v1/chat/completions"
          MODEL_NAME="gpt-4o-mini"
                    
          # Base directory where all artifacts for the package are stored
          BASE_PKG_DIR="cpi-artifacts/$PKG_ID"
                    
          if [ ! -d "$BASE_PKG_DIR" ]; then
            echo "::error::Package directory not found at: $BASE_PKG_DIR"
            echo "::error::Please ensure package artifacts were synced first and the Package ID ('$PKG_ID') is correct."
            echo "docs_generated=false" >> $GITHUB_OUTPUT
            exit 1
          fi
                    
          # --- Prompt Definitions: STRICT HIERARCHICAL STRUCTURE (Unchanged) ---
          SYSTEM_PROMPT="You are a senior SAP CPI Technical Architect. Your task is to analyze ALL provided code and configuration files from the SINGLE iFlow provided and synthesize them into ONE consolidated Markdown documentation report. You MUST adhere strictly to the following hierarchical 6-point structure, using Markdown headings (# for main sections, ## for subsections). Ensure all technical details (like Groovy, XSLT, Adapters, Security) are thoroughly explained within the relevant sections.
          **MANDATORY FIRST SECTION: TABLE OF CONTENTS (TOC) PAGE**
          The very first output of the document MUST be the Table of Contents. Format the TOC heading using HTML to achieve a prominent blue color and large font, like this: \`<h1 style=\"color: #1f4e79; font-size: 2.5em;\">Table of Contents</h1>\`. Below this heading, list all 6 main sections and their subsections using standard Markdown numbered list syntax (e.g., 1., 1.1., 1.2., etc.), ensuring proper indentation and **avoiding the use of HTML entities like &nbsp; for spacing**. Use a generous number of blank lines (e.g., 10 lines) after the TOC list to create maximum visual separation before starting Section 1.
          The mandatory sections and their required content mapping are:
          # 1. Introduction
          ## 1.1 Purpose (Map: Purpose of this iFlow)
          ## 1.2 Scope (Describe the boundaries and systems affected by this single iFlow)
          # 2. Integration Overview
          ## 2.1 Integration Architecture (Map: High-level architecture + Process Diagram)
          (Output the High-Level Process Flow Diagram immediately after the architecture text using only Mermaid syntax within a \`\`\`mermaid code block. The diagram must be a 'graph TD' (Top-Down) flowchart showing the major systems and their high-level interaction points, NOT the low-level iFlow steps. **CRITICAL: Ensure there is one blank line immediately following the closing \`\`\` of the Mermaid block.**)
          ## 2.2 Integration Components (Map: Sender/Receiver systems + Adapter types used)
          # 3. Integration Scenarios
          ## 3.1 Scenario Description (Map: Step-by-step flow explanation detailing the iFlow path)
          ## 3.2 Data Flows (Map: Mapping logic summary (XSLT/Mappings) + Groovy script explanations (usage/purpose))
          ## 3.3 Security Requirements (Map: Security/authentication details on mechanisms, credentials, and configuration)
          # 4. Error Handling and Logging (Map: Error handling details)
          # 5. Testing Validation (Summarize key testing requirements/scenarios based on iFlow logic)
          # 6. Reference Documents (List the input artifacts analyzed: iFlowContent.xml, Groovy scripts, XSLT files, etc.)"
                    
          # --- Main Logic: Find and Process Each iFlow Folder (omitted for brevity) ---
                    
          # ... (Logic to find and process IFLOW_FOLDERS, FULL_ARTIFACT_CONTENT, etc., remains here) ...
          
          FULL_IFLOW_PATHS=$(find "$BASE_PKG_DIR" -type f \( -name 'iFlowContent.xml' -o -name '*.iflw' \) -print)
                    
          if [ -z "$FULL_IFLOW_PATHS" ]; then
              echo "::warning::No iFlows found (no 'iFlowContent.xml' or '*.iflw' files) in package '$PKG_ID'. Skipping documentation."
              echo "docs_generated=false" >> $GITHUB_OUTPUT
              exit 0
          fi
                    
          IFLOW_ROOT_NAMES=$(echo "$FULL_IFLOW_PATHS" | sed "s|^$BASE_PKG_DIR/||" | cut -d/ -f1 | sort -u)
          IFLOW_FOLDERS=$(echo "$IFLOW_ROOT_NAMES" | xargs -I {} echo "$BASE_PKG_DIR/{}")
          ALL_DOCS_GENERATED=false
                    
          for IFLOW_DIR in $IFLOW_FOLDERS; do
            IFLOW_NAME=$(basename "$IFLOW_DIR")
            OUTPUT_FILE="$IFLOW_DIR/${IFLOW_NAME}_Summary.md"
                        
            echo "=================================================="
            echo "âž¡ Processing iFlow: $IFLOW_NAME (in $IFLOW_DIR)"
                        
            FULL_ARTIFACT_CONTENT=""
            FILES_TO_ANALYZE=$(find "$IFLOW_DIR" -type f \( -name 'iFlowContent.xml' -o -name '*.groovy' -o -name '*.xslt' -o -name '*.iflw' \) -print)
                        
            if [ -z "$FILES_TO_ANALYZE" ]; then
                echo "  âš ï¸ No supported artifacts found recursively in iFlow directory: $IFLOW_DIR. Skipping."
                continue
            fi
                        
            for INPUT_FILE in $FILES_TO_ANALYZE; do
              FILE_CONTENT=$(cat "$INPUT_FILE")
              FULL_ARTIFACT_CONTENT+="\n\n--- START ARTIFACT: $INPUT_FILE ---\n"
              FULL_ARTIFACT_CONTENT+="$FILE_CONTENT"
              FULL_ARTIFACT_CONTENT+="\n--- END ARTIFACT: $INPUT_FILE ---\n"
            done
                        
            echo "  Total size of consolidated input: ${#FULL_ARTIFACT_CONTENT} characters."
                        
            USER_QUERY="Synthesize a single, consolidated technical report following the 6 mandatory hierarchical sections and all sub-sections from the set of artifacts provided below, which belong ONLY to the iFlow '$IFLOW_NAME'. \n\n\`\`\`text\n$FULL_ARTIFACT_CONTENT\n\`\`\`"
                        
            PAYLOAD=$(jq -n \
              --arg system "$SYSTEM_PROMPT" \
              --arg query "$USER_QUERY" \
              --arg model "$MODEL_NAME" \
              '{
                model: $model,
                messages: [
                  {role: "system", content: $system},
                  {role: "user", content: $query}
                ],
                temperature: 0.1
              }')
                          
            JQ_EXIT_CODE=$?
            if [ "$JQ_EXIT_CODE" -ne 0 ]; then
                echo "::error::Failed to construct JSON payload using jq. Exit Code: $JQ_EXIT_CODE"
                echo "::error::This is often caused by invalid characters or excessively long content breaking the JSON structure."
                echo "docs_generated=false" >> $GITHUB_OUTPUT
                exit 1
            fi
                        
            MAX_RETRIES=3
            RETRY_COUNT=0
                        
            while [ "$RETRY_COUNT" -lt "$MAX_RETRIES" ]; do
              API_RESPONSE=$(curl -s -X POST "$API_URL" \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer $OPENAI_API_KEY" \
                -d "$PAYLOAD")
                              
              GENERATED_TEXT=$(echo "$API_RESPONSE" | jq -r ".choices[0].message.content")
                            
              if [ "$GENERATED_TEXT" != "null" ] && [ -n "$GENERATED_TEXT" ]; then
                echo "  âœ… Documentation generated successfully."
                # --- START COVER PAGE GENERATION LOGIC (WITH PAGE BREAKS) ---
                                
                # DYNAMIC METADATA COLLECTION
                AUTHOR=$(git log -1 --pretty=format:'%an')
                DATE=$(date +'%Y-%m-%d')
                VERSION=$(git rev-parse --short HEAD)
                                
                CLEAN_IFLOW_NAME=$(echo "$IFLOW_NAME" | sed 's/_/ /g')
                PROJECT_TITLE="AI Tech Specification Project - Odata Mass PDF upload"
                                
                # --- LOGO SETUP ---
                SAP_LOGO_URL="https://raw.githubusercontent.com/Rohancherian783/trail1/main/assets/sap_logo.png"
                MOTIVEMINDS_LOGO_URL="https://raw.githubusercontent.com/Rohancherian783/trail1/main/assets/motiveminds_logo.png"
                # --- END LOGO SETUP ---

                # 1. Top Logo Placement: SAP on Left, Motiveminds on Right
                # SAP size kept at 150x60
                SAP_LOGO_BLOCK="<div style=\"float: left; text-align: left;\"><img src=\"$SAP_LOGO_URL\" alt=\"SAP Logo\" width=\"150\" height=\"60\"/></div>"
                
                # ðŸ’¡ INCREASED MOTIVEMINDS LOGO SIZE (e.g., from 120x45 to 150x55)
                MOTIVEMINDS_LOGO_BLOCK="<div style=\"float: right; text-align: right;\"><img src=\"$MOTIVEMINDS_LOGO_URL\" alt=\"motiveminds Logo\" width=\"150\" height=\"55\" style=\"margin-top: 5px;\"/></div>"

                # Combine the logo blocks and clear the float. 
                COVER_PAGE_CONTENT="${SAP_LOGO_BLOCK}${MOTIVEMINDS_LOGO_BLOCK}<div style=\"clear: both;\"></div>\n\n\n\n\n\n\n"
                                
                # 2. Project Title and iFlow Name
                FULL_TITLE="$PROJECT_TITLE - $CLEAN_IFLOW_NAME"
                
                COVER_PAGE_CONTENT+="<h1 style=\"color: #1f4e79; font-size: 3em; text-align: left; margin-top: 100px;\">$FULL_TITLE</h1>"
                
                # Add newlines after the title
                COVER_PAGE_CONTENT+="\n\n\n\n\n\n"
                                
                # 3. Metadata block
                COVER_PAGE_CONTENT+="\n\n\n\n\n\n\n" 
                
                # HTML Table content (uses dynamic variables)
                COVER_PAGE_CONTENT+="<table border=\"1\" style=\"width: 400px; border-collapse: collapse; border-color: black;\">\n"
                COVER_PAGE_CONTENT+="  <tr><td style=\"width: 30%; padding: 5px;\">**Author:**</td><td style=\"padding: 5px;\">$AUTHOR</td></tr>\n"
                COVER_PAGE_CONTENT+="  <tr><td style=\"padding: 5px;\">**Date:**</td><td style=\"padding: 5px;\">$DATE</td></tr>\n"
                COVER_PAGE_CONTENT+="  <tr><td style=\"padding: 5px;\">**Version (Commit):**</td><td style=\"padding: 5px;\">$VERSION</td></tr>\n"
                COVER_PAGE_CONTENT+="</table>\n" # Added newline here
                                
                # ðŸ’¡ CRITICAL: PAGE BREAK AFTER COVER PAGE
                # This ensures the TOC starts on Page 2.
                COVER_PAGE_CONTENT+="\n<div style=\"page-break-after: always;\"></div>\n\n"
                                
                # We skip the original 23 newlines, as the page break handles separation

                # 4. Combine Cover Page and AI-generated Content (TOC is the first part of GENERATED_TEXT)
                FULL_DOCUMENTATION="${COVER_PAGE_CONTENT}${GENERATED_TEXT}"
                                
                # ðŸ’¡ CRITICAL: PAGE BREAK AFTER TOC (Which is the start of GENERATED_TEXT)
                # Since the AI output starts with the TOC, we need to locate the end of the TOC list 
                # before Section 1 to insert the second page break.
                # A robust way is to append the page break after the GENERATED_TEXT, 
                # and modify the AI prompt slightly to ensure Section 1 starts immediately after the TOC blank lines.
                
                # The prompt asks for 10 blank lines after the TOC list and before Section 1. 
                # We assume the TOC content structure is generated correctly by the AI.
                
                # Instead of trying to parse the AI output, let's inject the page break BEFORE Section 1.
                # Since the AI output starts with TOC, and includes 10 blank lines, we can replace those 10 blanks 
                # with one page break marker.
                
                # Replace the 10 or more blank lines between TOC and Section 1 with the page break marker.
                # We use 'sed' to replace the large block of newlines between the TOC and # 1. Introduction
                # This is an approximation since the number of \n the AI uses is variable.
                # Given the prompt mandates 10 blank lines:
                
                PAGE_BREAK_AFTER_TOC="\n<div style=\"page-break-after: always;\"></div>\n"
                
                # Regex: Search for many newlines followed by '# 1. Introduction' and replace the newlines with the page break
                # This is complex and fragile. The safest method is to modify the prompt and look for a simpler marker.
                
                # Alternative: Rely on the strict structure and add a second page break at the end of the generated text, 
                # which will force whatever comes next (if anything) onto a new page, but this might be unnecessary if 
                # the file ends after Section 6.
                
                # Let's rely on the AI's strict structure and use a marker:
                
                # 1. Modify the SYSTEM_PROMPT (outside this block) to use a distinct marker.
                # NEW INSTRUCTION for AI: ... Use a generous number of blank lines (e.g., 10 lines) after the TOC list to create maximum visual separation, then add the unique string '---TOC-END-PAGE-BREAK---' on its own line before starting Section 1.

                # If you don't want to change the prompt, we must rely on replacing the large block of whitespace:
                
                # CRITICAL: Replacing the whitespace between TOC and Section 1 with the page break.
                # We assume the AI respects the "10 lines" of separation before Section 1.
                
                # Search for multiple newlines followed by '# 1. Introduction' and insert the page break just before # 1.
                # The exact number of \n is hard to predict from the AI.
                
                # Let's use a simpler method based on the structure:
                # 1. The document is: [Cover Page] + [PB1] + [TOC + 10 lines + Section 1-6]
                
                # We will perform a search and replace *after* the generation:
                TOC_CLEANED_DOCUMENTATION=$(echo -e "$FULL_DOCUMENTATION" | sed -E "s/(\n{10,}# 1\. Introduction)/$PAGE_BREAK_AFTER_TOC# 1. Introduction/g")
                                
                # If the TOC is correctly formatted, this regex should find 10 or more newlines (\n{10,}) preceding the 
                # '# 1. Introduction' heading and replace them with the explicit page break HTML, forcing Section 1 
                # onto page 3.
                
                # Use the cleaned document for output
                echo -e "$TOC_CLEANED_DOCUMENTATION" > "$OUTPUT_FILE"

                echo "  ðŸ’¾ Saved documentation with cover page and page breaks to $OUTPUT_FILE"
                ALL_DOCS_GENERATED=true
                # --- END COVER PAGE GENERATION LOGIC ---
                                
                break
              else
                # ... (API failure/retry logic remains the same) ...
                ERROR_MSG=$(echo "$API_RESPONSE" | jq -r ".error.message // \"Unknown error\"")
                RETRY_COUNT=$((RETRY_COUNT + 1))
                DELAY=$((2**RETRY_COUNT))
                echo "  âš ï¸ API call failed: $ERROR_MSG (Attempt $RETRY_COUNT/$MAX_RETRIES). Retrying in $DELAY seconds..."
                sleep "$DELAY"
              fi
            done
                        
            if [ "$RETRY_COUNT" -eq "$MAX_RETRIES" ]; then
              echo "  âŒ Failed to generate documentation for iFlow: $IFLOW_NAME after $MAX_RETRIES attempts."
            fi
            echo "=================================================="
          done
                    
          # Set final output status
          echo "docs_generated=$ALL_DOCS_GENERATED" >> $GITHUB_OUTPUT
      # ... (Commit steps remain the same) ...
      - name: Commit All Generated iFlow Documentation
        if: steps.documentation_step.outputs.docs_generated == 'true'
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
                    
          PKG_ID="${{ github.event.inputs.package_id }}"
          OUTPUT_PATH="cpi-artifacts/$PKG_ID/**/*_Summary.md"
                    
          git add "$OUTPUT_PATH"
                    
          if git diff --cached --quiet "$OUTPUT_PATH"; then
              echo "No meaningful changes detected in the generated documentation files. Skipping commit."
          else
              git commit -m "ðŸ¤– DOCS: Generated/Updated individual iFlow summaries for package: $PKG_ID (GPT-4o mini)."
              git push
              echo "âœ… All iFlow documentation committed and pushed to repository."
          fi
